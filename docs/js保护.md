# 保护你的js代码

## Web前端JS代码需要保护吗？

这得具体情况具体分析。

1. 如果只是写一段web页面图片轮播，或是跑马灯效果等等之类简单的功能。那不需要保护。
2. 如果是精心设计一个绚丽的特效，如果想要保护这段自己付诸幸苦实现的特效代码不被他人随意拿去使用，那应该保护这段JS代码！
3. 如果页面上有重要的功能是用JS代码管控的，比如交易逻辑、帐号密码信息、个人隐私、甚至有与远程服务器或数据库的通信等等，那么相关的js代码非常应该被保护、应该做JS代码防盗保护！
否则可能引起被黑客分析、攻击等严重问题。安全相关的事情，从来都要防患于未然、不可心存侥幸。除非它对你毫不重要。


## 如何保护Web前端JS代码？

1. 打包&压缩
有人认为打包、压缩就是对JS代码的保护。确实，打包在一定程度上可以起码些许保护作用，好像看起来是如此。
但打包、压缩的目的并不是为了保护JS代码，而是为了使用方便、减小代码体积，方便使用、便于传输。比如模块化的编程可能产生200个JS文件，如果使用时逐一用“script src”进行引用……这是种折磨，不管是对于代发人员，还是网络加载（浏览器也会生气！x_x）。
类似Webpacket、Gulp进行打包，可以将这些多个JS合成到一个文件，并且可能会进行回车、换行、空格的删除，以实现代码压缩，也有一些简单混淆操作：把长变量名改为统一风格的短变量名等。
然后，最终生成的一个文件。代码总量减小了、可读性差了、使用方便了。
同时让有些人认为这也实现了JS代码保护。其实、实际上、当然的代码并没有被保护：可读性依旧，只是代码量大了一些而已，只要稍稍耐心的读代码，会发现，代码依然是很易理解的，没有多少安全性可言。

2. 混淆&加密
前端JS代码的保护，必需要混淆和加密共用。

单独的JS源代码加密，是行不通的，更不可能有所谓的JS不可逆加密。因为代码在浏览器端执行时，必须转解密还原成原始代码，才能被浏览器的JS引擎识别和运行。

在解密后，会存在完整的原始JS代码。这是非常不安全的存在，有多种方法可将原始的JS代码显示出来。

JS代码混淆被不少开发人员认为是不够高端的JS代码保护方式，听起来不如JS源码加密更具安全性。

事实上，混淆也有多个级别。比如比较低端的字符搜索和串替换、随机插入伪僵尸代码、字符串十六进制化等等。而也有高端的手法，会先进行语法分析、词法分析，重建语法树，相当于已经实现了一个JS引擎，在引擎中处理代码，那么，就可以在其中任意一步进行自由度极高的操作，比如在语法树中插入新的语法结构、比如可以将字符串全部提取并进行加密、可以对变量进行整体有规则化的重定义使无意义化等等。
这样就可以实现真正的代码重建。这样重建的JS代码安全性，将会有一个质的提升。

当混淆和加密联合使用，可以实现真正的JS代码安全保护。
JS混淆中融入JS加密，JS加密中又嵌入JS混淆。这样保护后的代码，即使在客户端执行环境中被逆向还原，得到的也是大量含义不明的函数、代码、字符串。

特别重点是：代码已经经过了重建，这时逆向得到的也是分离后的重建的无意义JS代码、大量的僵尸代码、混淆的字符串、不明含意的变量。可读性与原始代码相比……天壤之别。
固执的人或许还会说：没有破解不了的保护方案，只要我认真、用心、用时的分析，还是能分析出原始代码含意的，确实，可能如此。
但是，原本的代码，可能只需要读10分钟，而从这样保护后的JS代码读取原始含意，可能需要……10个月。而这时候，我们的JS代码可能已经更新到下一版了。
JS代码保护的目的已经达到了，不是吗？


## 如何保护前端js代码？
### 为什么要对js代码进行保护？

1. js代码运行于客户端
2. js代码是公开透明的

由于这两个原因，致使js代码是不安全的，任何人都可以读、分析、复制、盗用，甚至篡改。因此出现了很多安全事件，典型的如： 自己的原创程序代码被盗用、网站数据被篡改等等。

如果你不想让自己的代码被他人看到、不想他人了解你的代码功能，或者想降低被不怀好意的人甚至是黑客攻击，那么你应该尝试使用js保护。

### 如何对js代码进行保护？

1. 使js代码不可读，让攻击者无法理解代码功能，也无法篡改任何功能
2. 代码不可读之后，攻击者往往会进行动态跟踪调试，以期逆向还原出原始代码，或分析出程序功能。因此， 使js代码不可分析，不能进行动态跟踪调试，成为另一种保护重心。

实现以上两点后，js代码即可得到保护。

### 具体的保护方案、保护技术是什么？

要实现 js 代码的不可读，不可分析，有以下几大类技术方案：

代码加密： 加密后的代码看似乎杂乱，但代码在执行前需要进行解密才能执行，只要找到解密函数即可还原出原始代码，所以此方式安全系数较低；

虚拟机技术：可以屏蔽js原始关键字，但兼容性较差，无法保证在多端，多浏览器下运行；

代码混淆：使用字符串阵列化、平展控制流、多态变异，僵尸函数等手段，使代码变得不可读不可分析，达到最终保护的目的。且不影响代码原有功能。是理想、实用的js保护方案。

## js代码保护主要技术释义

变量混淆： 将带有含义的变量名、函数名、常量名随机变为无意义的类乱码字符串，降低代码可读性。

字符串加密： 将字符串阵列化集中放置、并可进行MD5或base64加密存储。使代码中不出现明文字符串。

平展控制流： 打乱函数原有代码执行流程及函数调用关系，使代码逻辑变得混乱无序。

僵尸代码：随机在代码中插入无用的僵尸代码、僵尸函数，进一步使代码混乱。

代码压缩：移除无用的空格、回车、注释、调试语句等，即可压缩代码使文件变小易于加载，又起到混乱的效果。

多态变异：使js代码每次被调用（引用），代码自身即立刻自动发生变异，变化为与之前完全不同的代码（功能完全不变，只是代码形式变异），以此杜绝代码被动态分析调试！


### 配置选项
#### 常用：
 - 压缩代码: 去除回车换行、空格。减小代码体积的同时使代码难以正常阅读。
 - 混淆局部变量: 将变量、函数名称统一修改为型如：0x00ABX的形式，使代码可读性大幅度降低。
 - 混淆全局变量和函数名: 同上
 - 反代码美化: 防止压缩后的代码被代码美化工具还原。

#### 高级：
 - 平展控制流： 通过组合拆分的方式，更改代码原有的分枝逻辑，打乱代码原有的相关系，使代码变的不可理解
 - 字符串阵列化： 将字符串进行阵列化放置，使赋值、读写等操作不易被查觉。
 - 混淆字符串阵列： 使不出现明文字符串、常量。
 - 字符串加密： 对混淆后的字符串进行再次加密，使破解更加困难。

#### 可选：
 - 禁用命令行输出： 剔除命令行调试语句，使不打印出调试信息。
 - 反调试： 使浏览器调试工具不可用，适用于chrome、火狐等浏览器。
 - 域名锁定： 使代码只能在指定的域名（含子域名）下运行，复制到其它任何地方、任何网站都无法运行。 此功能可以防止产品被复制盗用。
     添加域名
     域名列表显示/删除


#### NodeJS代码保护： 
可保护应用于NodeJS的服务端源码，防止产品、项目源码部署于服务器端时发生泄漏。

#### 多态变异和代码托管： 
使用“代码托管”和“多态变异”功能时。保护后的代码会保存在服务器，它的好处是：js保护技术更新后、推出更强更安全的保护方案后，代码会即时得到同步安全升级，时刻使用最新最安全的保护方案。
同时，托管的代码具有多态变异功能，即：每次代码被调用，JS文件内容会自动发生变化。此保护技术会杜绝代码被不法者动态调试的可能性。













